# -*- coding: utf-8 -*-
"""Final_Project_Rev1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hQ_bEA8ZKAj5EyiGlU9X3JTYA6k-OO_D

# **GELİR TAHMİNİ**

---

Malcolm GLADWELL' in Outliers adlı kitabı, elde ettikleri başarılar ve hayat hikayetleriyle diğer insanlardan farklılaşan kişiler üzerine yapılmış bir çalışmadır. Çalışma kapsamında başarılı kişilerin, kişisel özelliklerinin yanı sıra ekonomik, demografik, sosyolojik, kültürel, fiziksel vb. dış çevre özeliklerinin de dikkate alınması gerektiği vurgulanarak daha geniş bir perspektiften konu ele alınmıştır ([Outliers, GLADWELL M.](https://www.gladwellbooks.com/titles/malcolm-gladwell/outliers/9780316040341/)). 

![indir.jpg](data:image/jpeg;base64,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)

Yukarıda bahsi geçen çalışmadan esinlenerek University of California Center of Machine Learning and Intelligent Systems' in internet sitesinde yer alan "Adult" adlı veri seti kullanılarak demografik, sosyolojik, kültürel vb. özelliklerle örneklemin gelir düzeylerinin 50K' danbüyük olup olmadığı tahmin edilmeye çalışılmıştır ([Machine Learning Repository](https://archive.ics.uci.edu/ml/datasets/Adult)). 

---

**VERİ SETİ AÇIKLAMASI**\
Veri seti, 1994 Nüfus Sayım Sonuçları veri tabanından Barry Becker tarafından yapılmıştır. Bazı koşullar kullanılarak bir dizi kayıt veri setindençıkarılmıştır.

**Değişkenler**
- age: Yaş
- workclass: Çalışma Şekli (*Private, Self-emp-not-inc, Self-emp-inc, Federal-gov, Local-gov, State-gov, Without-pay, Never-worked*)
- fnlwgt: Benzer sosyo-ekonomik özelliklere sahip her bir personanın toplam eleman sayısıdır.
- education: Eğitim Durumu (*Bachelors, Some-college, 11th, HS-grad, Prof-school, Assoc-acdm, Assoc-voc, 9th, 7th-8th, 12th, Masters, 1st-4th, 10th, Doctorate, 5th-6th, Preschool*)
- education_num: Eğitim Süresi
- marital_status: Medeni Durumu (*Married-civ-spouse, Divorced, Never-married, Separated, Widowed, Married-spouse-absent, Married-AF-spouse*)
- occupation: Meslek (*Tech-support, Craft-repair, Other-service, Sales, Exec-managerial, Prof-specialty, Handlers-cleaners, Machine-op-inspct, Adm-clerical, Farming-fishing, Transport-moving, Priv-house-serv, Protective-serv, Armed-Forces*)
- relationship: İlişki Durumu (*Wife, Own-child, Husband, Not-in-family, Other-relative, Unmarried*)
- race: Irk (*White, Asian-Pac-Islander, Amer-Indian-Eskimo, Other, Black*)
- sex: Cinsiyet (*Female, Male*)
- capital_gain: Yatırım Kazancı
- capital_loss: Yatırım Kaybı
- hours_per_week: Haftalık Çalışma Süresi
- native-country: Oirijin Ülke (*United-States, Cambodia, England, Puerto-Rico, Canada, Germany, Outlying-US(Guam-USVI-etc), India, Japan, Greece, South, China, Cuba, Iran, Honduras, Philippines, Italy, Poland, Jamaica, Vietnam, Mexico, Portugal, Ireland, France, Dominican-Republic, Laos, Ecuador, Taiwan, Haiti, Columbia, Hungary, Guatemala, Nicaragua, Scotland, Thailand, Yugoslavia, El-Salvador, Trinadad&Tobago, Peru, Hong, Holand-Netherlands*)
- income: Gelir (*>50K veya <=50K*)

**Kütüphanelerin Yüklenmesi**
"""

# Kütüphanelerin Yüklenmesi
import warnings
import numpy as np
import pandas as pd
import seaborn as sns
from matplotlib import pyplot as plt
from sklearn.preprocessing import MinMaxScaler, LabelEncoder, StandardScaler, RobustScaler
from sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier, VotingClassifier, AdaBoostClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.model_selection import cross_validate, GridSearchCV, validation_curve
from sklearn.neighbors import KNeighborsClassifier
from sklearn.svm import SVC
from sklearn.tree import DecisionTreeClassifier
from xgboost import XGBClassifier
from lightgbm import LGBMClassifier
!pip install catboost
from catboost import CatBoostClassifier
from sklearn.metrics import accuracy_score, roc_auc_score, confusion_matrix, classification_report, plot_roc_curve

"""**Veri Setinin Yüklenmesi**"""

# Veri Setinin Yüklenmesi
col_names = ["age", "workclass", "fnlwgt", "education", "education_num", "marital_status", "occupation", \
             "relationship", "race", "sex", "capital_gain", "capital_loss", "hours_per_week", "native_country",\
             "income"]
df_train = pd.read_csv("/content/drive/MyDrive/Kişisel Dosyalar/adult_train.csv", header=None, index_col=False, names=col_names)
df_train["first_situation"]="train"
df_test = pd.read_csv("/content/drive/MyDrive/Kişisel Dosyalar/adult_test.csv", header=None, skiprows=1, index_col=False, names=col_names)
df_test["first_situation"]="test"

"""**Veri Setinin Birleştirilmesi**\
Daha sonra gerçekleştirilecek encoding işlemlerinin tüm veri setinde uygulanması maksadıyla train ve test veri seti başlangıçta birleştirilmiştir.
"""

# Veri Setinin Birleştirilmesi 
df = df_train.append(df_test).reset_index(drop=True)

"""**Veri Setine Genel Bakış**\
Veri setinde bir bağımlı değişken ve 15 bağımsız değişken olmak üzere toplam 16 değişken bulunmaktadır. Bu değişkenlerin 6' sı sayısal tipte geriye kalan 10' u kategorik tipte değişken görünümündedir. Veri setinde toplam 48.842 kayıt bulunmaktadır. Eksik değerin olmadığı bir görünümdedir.
"""

# Veri Setine Genel Bakış


def check_df(dataframe, head=5):
    print(f"\nVERİ SETİNİN BOYUTU")
    print(dataframe.shape)
    print(f"\nDEĞİŞKEN TİPLERİ")
    print(dataframe.dtypes)
    print(f"\nİLK 5 DEĞER")
    print(dataframe.head(head))
    print(f"\nSON 5 DEĞER")
    print(dataframe.tail(head))
    print(f"\nEKSİK DEĞERLER")
    print(dataframe.isnull().sum())
    print(f"\nBETİMLEYİCİ İSTATİSTİK")
    print(dataframe.quantile([0, 0.01, 0.50, 0.95, 0.99, 1]).T)
    

check_df(df)

"""**Keşifçi Veri Analizi (EDA)**\
Veri setinde workclass, occuptaion ve native_country değişkenlerinden değerlerde ? ifadesinin yer aldığı görülmektedir. Ayrıca education ve education_num değişkenlerine ait değerlerin sınıflarındaki frekans ve oranların birebir aynı olduğu görülmektedir.
"""

# EDA


def cat_summary(dataframe, col_name):
    print(pd.DataFrame({col_name: dataframe[col_name].value_counts(),
                        "Ratio": 100 * dataframe[col_name].value_counts() / len(dataframe)}))
    print("##########################################")


for col in df.columns:
    cat_summary(df, col)

"""**Özellik Mühendisliği**\
Gelirin 50K' dan büyük olmasının yaş değişkeniyle yakından ilişkili olabileceği düşünülerek age değişkeninden young, mature ve senior sınıfında new_age_cat değişkeni oluşturulmuştur.

Geliri 50K' dan büyük olanların kişinin yalnız yaşayıp yaşamadığıyla yakından ilişkili olabileceği düşünülerek relationship değişkeninden boolen türünde new_is_alone değişkeni oluşturulmuştur.

Geliri 50K' dan büyük olanların orijinlerinin belirli bir kıtadan olabileceği düşünülerek native_country değişkeninden North America, South America, Europe ve Asia sınıfında new_continent değişkeni oluşturulmuştur.  native_country değişkenindeki boş değerler için new_continent değişkeninde Unknown sınıfı oluşturulmuştur.

Geliri 50K' dan büyük olanların çalışma sektörlerinin belirli bir grupta olabileceği düşünülerek workclass değişkeninden Serbest, Kamu ve Ucretsiz sınıfında new_work_class değişkeni oluşturulmuştur.  workclass değişkenindeki boş değerler için new_work_class değişkeninde Unknown sınıfı oluşturulmuştur.

Keşifçi veri analizi bulguları doğrultusunda veri setinde workclass, occupation ve native_country değişkenlerindeki ? değerleri silinmiştir. 

Keşifçi veri analizi bulguları doğrultusunda education ve education_num değişkenlerine ait değerlerin sınıflarındaki frekans ve oranların birebir aynı olması sebebiyle education değişkeni veri setinden silinmiştir.

Income değişkeninde ">50K" ve ">50K." şeklindeki string değerlerin aynı değeri temsil ettiği, "<=50K" ve "<=50K." şeklindeki string değerlerin de yine aynı değeri temsil ettiği belirlenmiş ve ">50K" ve ">50K." string ifadeler 1 değeriyle, "<=50K" ve "<=50K." 0 değeriyle değiştirilmiştir.
"""

# age Değişkeni Üzerinden Gruplandırma Yapılarak Yeni Değişken Üretilmesi
df.loc[(df['age'] < 18), 'new_age_cat'] = 'young'
df.loc[((df['age'] >= 18) & (df['age'] < 56)), 'new_age_cat'] = 'mature'
df.loc[(df['age'] >= 56), 'new_age_cat'] = 'senior'

# relationship Değişkeni Üzerinden Gruplandırma Yapılarak Yeni Değişken Üretilmesi
df["new_is_alone"] = df["relationship"].apply(lambda x: "Yes" if x.strip() == "Not-in-family" else "No")

# native_country Değişkeni Üzerinden Gruplandırma Yapılarak Yeni Değişken Üretilmesi
north_america_countries = ["Jamaica", "Mexico", "Cuba", "Canada", "United-States", "Puerto-Rico", "Haiti", "Dominican-Republic", \
                           "El-Salvador", "Nicaragua", "Guatemala", "Honduras", "Trinadad&Tobago", "Outlying-US(Guam-USVI-etc)"]
south_america_countries = ["Ecuador", "Colombia", "Peru"]
europe_countries = ["England", "France", "Germany", "Greece", "Holand-Netherlands", "Hungary", "Ireland", "Italy", "Poland", "Portugal", "Scotland", "Yugoslavia"]
asia_countries = ["Iran", "Japan", "India", "Philippines", "Taiwan", "Thailand", "Vietnam", "China", "South", "Laos", "Cambodia", "Hong"]

for i in north_america_countries:
  df.loc[df["native_country"].str.contains(i), "new_continent"] = "North America" 

for i in south_america_countries:
  df.loc[df["native_country"].str.contains(i), "new_continent"] = "South America" 

for i in europe_countries:
  df.loc[df["native_country"].str.contains(i), "new_continent"] = "Europe" 

for i in asia_countries:
  df.loc[df["native_country"].str.contains(i), "new_continent"] = "Asia"

df["new_continent"].fillna(value="Unknown", axis=0, inplace=True)

# workclass Değişkeni Üzerinden Gruplandırma Yapılarak Yeni Değişken Üretilmesi
df.loc[df["workclass"].str.contains("Private"), "new_work_class"] = "Serbest"
df.loc[df["workclass"].str.contains("Self-emp-not-inc"), "new_work_class"] = "Serbest"
df.loc[df["workclass"].str.contains("Self-emp-inc"), "new_work_class"] = "Serbest"
df.loc[df["workclass"].str.contains("Local-gov"), "new_work_class"] = "Kamu"
df.loc[df["workclass"].str.contains("State-gov"), "new_work_class"] = "Kamu"
df.loc[df["workclass"].str.contains("Federal-gov"), "new_work_class"] = "Kamu"
df.loc[df["workclass"].str.contains("Without-pay"), "new_work_class"] = "Ucretsiz"
df.loc[df["workclass"].str.contains("Never-worked"), "new_work_class"] = "Ucretsiz"
df["new_work_class"].fillna(value="Unknown", axis=0, inplace=True)

# Değişkenlerde Yer Alan Soru İşareti Değerlerinin Silinmesi
for col in ["workclass", "occupation", "native_country"]:
    df[col] = df[col].str.strip().map(lambda x: np.nan if x=="?" else x)

# education Değişkeninin Silinmesi
df.drop("education", axis=1, inplace=True)

# income Değişkeninin Standartlaştırılması
df["income"] = df["income"].apply(lambda x: 1 if ">50K" in x else 0)

"""**Değişken Tiplerinin Belirlenmesi**"""

# Değişken Tiplerinin Belirlenmesi


def grab_col_names(dataframe, cat_th=10, car_th=20):
    """

    Veri setindeki kategorik, numerik ve kategorik fakat kardinal değişkenlerin isimlerini verir.
    Not: Kategorik değişkenlerin içerisine numerik görünümlü kategorik değişkenler de dahildir.

    Parameters
    ------
        dataframe: dataframe
                Değişken isimleri alınmak istenilen dataframe
        cat_th: int, optional
                numerik fakat kategorik olan değişkenler için sınıf eşik değeri
        car_th: int, optinal
                kategorik fakat kardinal değişkenler için sınıf eşik değeri

    Returns
    ------
        cat_cols: list
                Kategorik değişken listesi
        num_cols: list
                Numerik değişken listesi
        cat_but_car: list
                Kategorik görünümlü kardinal değişken listesi

    Examples
    ------
        import seaborn as sns
        df = sns.load_dataset("iris")
        print(grab_col_names(df))


    Notes
    ------
        cat_cols + num_cols + cat_but_car = toplam değişken sayısı
        num_but_cat cat_cols'un içerisinde.
        Return olan 3 liste toplamı toplam değişken sayısına eşittir: cat_cols + num_cols + cat_but_car = değişken sayısı

    """

    # cat_cols, cat_but_car
    cat_cols = [col for col in dataframe.columns if dataframe[col].dtypes == "O"]
    num_but_cat = [col for col in dataframe.columns if dataframe[col].nunique() < cat_th and
                   dataframe[col].dtypes != "O"]
    cat_but_car = [col for col in dataframe.columns if dataframe[col].nunique() > car_th and
                   dataframe[col].dtypes == "O"]
    cat_cols = cat_cols + num_but_cat
    cat_cols = [col for col in cat_cols if col not in cat_but_car]

    # num_cols
    num_cols = [col for col in dataframe.columns if dataframe[col].dtypes != "O"]
    num_cols = [col for col in num_cols if col not in num_but_cat]

    print(f"Observations: {dataframe.shape[0]}")
    print(f"Variables: {dataframe.shape[1]}")
    print(f'cat_cols: {len(cat_cols)} {cat_cols}')
    print(f'num_cols: {len(num_cols)} {num_cols}')
    print(f'cat_but_car: {len(cat_but_car)} {cat_but_car}')
    print(f'num_but_cat: {len(num_but_cat)} {num_but_cat}')
    return cat_cols, num_cols, cat_but_car, num_but_cat


cat_cols, num_cols, cat_but_car, num_but_cat = grab_col_names(df, 10, 50)

"""**Kategorik Değişken Analizi**"""

# Kategorik Değişken Analizi


def cat_summary(dataframe, col_name, plot=False):
    print(pd.DataFrame({col_name: dataframe[col_name].value_counts(),
                        "Ratio": 100 * dataframe[col_name].value_counts() / len(dataframe)}))

    if plot:
        ax = sns.countplot(x=dataframe[col_name], data=dataframe)
        ax.set_xticklabels(ax.get_xticklabels(),rotation = 90)                
        plt.show(ax)


for col in cat_cols:
    cat_summary(df, col, True)

"""**Sayısal Değişken Analizi**"""

# Sayısal Değişken Analizi


def num_summary(dataframe, numerical_col, plot=False):
    quantiles = [0.05, 0.10, 0.20, 0.30, 0.40, 0.50, 0.60, 0.70, 0.80, 0.90, 0.95, 0.99]
    print(dataframe[numerical_col].describe(quantiles).T)

    if plot:
        dataframe[numerical_col].hist(bins=50)
        plt.xlabel(numerical_col)
        plt.title(numerical_col)
        plt.show()

    print("#####################################")


for col in num_cols:
    num_summary(df, col, True)

"""**Hedef Değişken Analizi**\
workclass değişkeninde Never-worked sınıfındaki personanın, benzer şekilde new_age_cat değişkeninde young sınıfındaki personanın hedef değişkene hiç bir katkısının olmadığı görülmektedir. Bu sebeple new_age_cat değişkenindeki young sınıfı ve workclass değişkenindeki never_worked sınıfına ait değerler veri setinden silinmiştir.

Geliri 50K' nın üzerinde olanların oranı şirket sahibi serbest meslek erbabında, doktora yapmış olanlarda, eşi sivil evlilerde, yönetici pozisyonunda olanlarda, sarı ırk mensuplarında, erkeklerde, 56 yaş üzerinde, yalnız yaşamayanlarda, Avrupa' lılarda, kamuda çalışanlarda ve Fransız kökenlilerde daha yüksektir.

Geliri 50K' nın üzerinde olanların frekansı özel sektör çalışanlarında, lisans mezunlarında, eşi sivil evlilerde, yönetici pozisyonunda olanlarda, beyaz ırk mensuplarında, erkeklerde, 18 yaş üzeri yetişkinlerde, yalnız yaşamayanlarda, Kuzey Amerika' lılarda, serbest çalışanlarda ve Amerika Birleşik Devletleri kökenlilerde daha yüksektir.

"""

# Hedef Değişken Analizi


def target_summary_with_cat(dataframe, target, categorical_col):
    print(pd.DataFrame({"TARGET_MEAN": dataframe.groupby(categorical_col)[target].mean(), \
                        "TARGET_FREQUENCY": dataframe.groupby(categorical_col)[target].sum()}), end="\n\n")


for col in cat_cols:
    target_summary_with_cat(df,"income",col)

# Hedef Değişken Üzerinde Etkisi Olmayan Değerlerin Silinmesi
df = df.drop(df.loc[df["workclass"].str.strip() == "Never-worked"].index)
df = df.drop(df.loc[df["new_age_cat"] == "young"].index)
df = df.drop(df.loc[df["native_country"] == "Holand-Netherlands"].index)

"""**Korelasyon Analizi**\
Korelasyon analizi neticesinde sayısal değişkenler arasında pozitif veya negatif korelasyona sahip herhangi bir değişken tespit edilmemiştir.
"""

# Korelasyon Analizi


def high_correlated_cols(dataframe, plot=False, corr_th=0.70):
    corr = dataframe.corr()
    cor_matrix = corr.abs()
    upper_triangle_matrix = cor_matrix.where(np.triu(np.ones(cor_matrix.shape), k=1).astype(np.bool))
    drop_list = [col for col in upper_triangle_matrix.columns if any(upper_triangle_matrix[col] > corr_th)]
    if plot:
        sns.set(rc={'figure.figsize': (7, 7)})
        sns.heatmap(corr, cmap="RdBu")
        plt.show()        
    return drop_list


drop_list = high_correlated_cols(df, True)
print(drop_list)

"""**Aykırı Değer Analizi**\
Sayısal değişkenlerde herhangi bir aykırı değer tespit edilmemiştir.
"""

# Aykırı Değer Analizi


def outlier_thresholds(dataframe, variable, low_quantile=0.01, up_quantile=0.99):
    quantile_one = dataframe[variable].quantile(low_quantile)
    quantile_three = dataframe[variable].quantile(up_quantile)
    interquantile_range = quantile_three - quantile_one
    up_limit = quantile_three + 1.5 * interquantile_range
    low_limit = quantile_one - 1.5 * interquantile_range
    return low_limit, up_limit


def check_outlier(dataframe, col_name):
    low_limit, up_limit = outlier_thresholds(dataframe, col_name)
    if dataframe[(dataframe[col_name] > up_limit) | (dataframe[col_name] < low_limit)].any(axis=None):
        return True
    else:
        return False


for col in num_cols:
    if col != "income":
      print(col, check_outlier(df, col))

"""**Aykırı Değerlerin Baskılanması**\
fnlwgt Amerika Birleşik Devletleri' nde benzer sosyo-ekonomik özelliklere sahip her bir personanın toplam eleman sayısını vermekte olup veri setinden daha büyük bir anakitlenin özelliklerini barındırdığı için aykırı değer baskılama işlemi tercih edilmemiştir.

capital_gain ve capital_loss değişkenindeki aykırı değerlerin baskılanması tercih edilmiştir.
"""

# Aykırı Değerlerin Baskılanması


def replace_with_thresholds(dataframe, variable):
    low_limit, up_limit = outlier_thresholds(dataframe, variable)
    dataframe.loc[(dataframe[variable] < low_limit), variable] = low_limit
    dataframe.loc[(dataframe[variable] > up_limit), variable] = up_limit


replace_with_thresholds(df, "capital_gain")

for col in num_cols:
    if col != "income":
      print(col, check_outlier(df, col))

"""**Eksik Değer Analizi**\
Veri setinde workclass, occupation ve native_country değişkenlerinde eksik değerler olduğu tespit edilmiştir. Bu sebeple eksik değerlerin hedef değişkenle analizi gerçekleştirilmiştir.
"""

# Eksik Değer Analizi


def missing_values_table(dataframe, na_name=False):
    na_columns = [col for col in dataframe.columns if dataframe[col].isnull().sum() > 0]
    n_miss = dataframe[na_columns].isnull().sum().sort_values(ascending=False)
    ratio = (dataframe[na_columns].isnull().sum() / dataframe.shape[0] * 100).sort_values(ascending=False)
    missing_df = pd.concat([n_miss, np.round(ratio, 2)], axis=1, keys=['n_miss', 'ratio'])
    print(missing_df, end="\n")

    if na_name:
        return na_columns


missing_values_table(df, True)

"""**Eksik Değerlerin Bağımlı Değişken ile Analizi**\
Eksik değerlerin hedef değişkeni ile analizi neticesinde workclass ve occupation değişkeninde eksik değere sahip olan personaların gelirinin 50K' dan büyük olma olasılığı % 6 civarında olduğu, benzer şekilde native_country değişkeninde eksik değere sahip olan personaların gelirinin 50K' dan büyük olma olasılığının ise % 2 civarında olduğu tespit edilmiştir. Bu sebeple söz konusu değişkenlerde eksik değere sahip olup olmama üzerinden yeni değişkenler türetilmiştir.
"""

na_cols = missing_values_table(df, True)


def missing_vs_target(dataframe, target, na_columns):
    temp_df = dataframe.copy() 

    for col in na_columns: 
        temp_df[col + '_NA_FLAG'] = np.where(temp_df[col].isnull(), 1, 0) 

    na_flags = temp_df.loc[:, temp_df.columns.str.contains("_NA_")].columns 

    for col in na_flags:
        print(pd.DataFrame({"TARGET_MEAN": temp_df.groupby(col)[target].mean(),
                            "Count": temp_df.groupby(col)[target].count()}), end="\n\n")
        
    return temp_df    

df = missing_vs_target(df, "income", na_cols)

"""**Değişken Tiplerinin Yeniden Belirlenmesi**"""

# Değişken Tiplerinin Yeniden Belirlenmesi
cat_cols, num_cols, cat_but_car, num_but_cat = grab_col_names(df, 10 , 50)

"""**Keşifçi Veri Analizinin Yinelenmesi**"""

# Keşiçi Veri Analizinin Yinelenmesi
for col in df.columns:
    cat_summary(df, col)

"""**Rare Analizi**\
Rare analizi neticesinde frekansı, oranı ve hedef değişken açısından ortalaması dikkate alınarak gruplandırılabilecek herhangi bir değer tespit edilmemiştir.
"""

# Rare Analizi


def rare_analyser(dataframe, target, cat_cols):
    for col in cat_cols:
        print(col, ":", len(dataframe[col].value_counts()))
        print(pd.DataFrame({"COUNT": dataframe[col].value_counts(),
                            "RATIO": dataframe[col].value_counts() / len(dataframe),
                            "TARGET_MEAN": dataframe.groupby(col)[target].mean()}), end="\n\n\n")


rare_analyser(df, "income", cat_cols)

"""**Label Encoding**"""

# Label Encoding


def label_encoder(dataframe, binary_col):
    labelencoder = LabelEncoder()
    dataframe[binary_col] = labelencoder.fit_transform(dataframe[binary_col])
    return dataframe


binary_cols = [col for col in df.columns if df[col].dtype not in [int, float] and df[col].nunique() == 2]

for col in binary_cols:
    df = label_encoder(df, col)

"""**One Hot Encoding**"""

# One Hot Encoding


def one_hot_encoder(dataframe, categorical_cols, drop_first=True):
    dataframe = pd.get_dummies(dataframe, columns=categorical_cols, drop_first=drop_first)
    return dataframe


df = one_hot_encoder(df, cat_cols)

"""**Kullanışsız Değişkenler**\
Hedef değişken üzerinde etkisi % 0,1' in altında olan değişkenler veri setinden silinmiştir. 
"""

# Kullanışsız Değişkenler
useless_cols = [col for col in df.columns if df[col].nunique() == 2 and (df[col].value_counts() / len(df) < 0.001).any(axis=None)]
print(useless_cols)
df.drop(useless_cols, axis=1, inplace=True)

"""**Standard Scaling**"""

# Standard Scaling
scaler = StandardScaler()
df[num_cols] = scaler.fit_transform(df[num_cols])

"""**Veri Setinin Train ve Test Olarak Bölünmesi**"""

# Veri Setinin Train ve Test Olarak Bölünmesi
df_train = df.loc[df["first_situation_1"]==1]
df_test = df.loc[df["first_situation_1"]==0]
train_y = df_train["income_1"]
train_X = df_train.drop(["income_1"], axis=1)
test_y = df_test["income_1"]
test_X = df_test.drop(["income_1"], axis=1)

"""**Model**"""

# Model


classifiers = [('LR', LogisticRegression()),
               ('KNN', KNeighborsClassifier()),
               ("SVC", SVC()),
               ("CART", DecisionTreeClassifier()),
               ("RF", RandomForestClassifier()),
               ('GBM', GradientBoostingClassifier()),
               ('XGBoost', XGBClassifier(use_label_encoder=False, eval_metric='logloss')),
               ('LightGBM', LGBMClassifier()),
               ('CatBoost', CatBoostClassifier(verbose=False))
               ]

for name, classifier in classifiers:
    cv_results = cross_validate(classifier, train_X, train_y, cv=3, scoring=["roc_auc","accuracy"])
    print("roc_auc : ", f" {round(cv_results['test_roc_auc'].mean(), 4)} ({name})")
    print("acc     : ", f" {round(cv_results['test_accuracy'].mean(), 4)} ({name})")
    print("***********")

"""**Hiperparametre Optimizasyonu**"""

# Hiperparametre Optimizasyonu
catboost_model = CatBoostClassifier(verbose=False)
catboost_params = {"iterations": [200, 500],
                   "learning_rate": [0.01, 0.1],
                   "depth": [3, 6]}
catboost_best_grid = GridSearchCV(catboost_model, catboost_params, cv=5, n_jobs=-1, verbose=True).fit(train_X, train_y)

# Hiperparametre Optimizasyonu Sonucu Train Veri Setinde Model Başarısı
catboost_final = catboost_model.set_params(**catboost_best_grid.best_params_).fit(train_X, train_y)
cv_results = cross_validate(catboost_final, train_X, train_y, cv=5, scoring=["accuracy", "f1", "roc_auc"])
print(cv_results['test_roc_auc'].mean())
print(cv_results['test_accuracy'].mean())

# Hiperparametre Optimizasyonu Sonucu Test Veri Setinde Model Başarısı
cv_results = cross_validate(catboost_final, test_X, test_y, cv=5, scoring=["accuracy", "f1", "roc_auc"])
print(cv_results['test_roc_auc'].mean())
print(cv_results['test_accuracy'].mean())

"""**Confusion Matrix**\
train veri setinde geliri 50K' dan büyük olmayan 23.278 kişi doğru, test veri setinde ise 11.506 kişi doğru tahmin edilmiştir. 

train veri setinde geliri 50K' dan büyük olan 5.633 kişi doğru, test veri setinde ise 2.507 kişi doğru tahmin edilmiştir.

train veri setinde geliri 50K' dan büyük olmayan 1.040 kişinin geliri 50K' dan büyük olarak, test veri setinde geliri 50K' dan büyük olmayan 727 kişinin geliri 50K' dan büyük olarak tahmin edilmiştir. 

train veri setinde geliri 50K' dan büyük olan 2.208 kişinin geliri 50K' dan küçük olarak, test veri setinde geliri 50K' dan büyük olan 1.339 kişinin geliri 50K' dan küçük olarak tahmin edilmiştir. 
"""

# Confusion Matrix
train_pred = catboost_final.predict(train_X)
test_pred = catboost_final.predict(test_X)


def plot_confusion_matrix(y, y_pred):
    acc = round(accuracy_score(y, y_pred), 2)
    cm = confusion_matrix(y, y_pred)
    sns.heatmap(cm, annot=True, fmt=".0f")
    plt.xlabel('y_pred')
    plt.ylabel('y')
    plt.title('Accuracy Score: {0}'.format(acc), size=10)
    plt.show()

plot_confusion_matrix(train_y, train_pred)
plot_confusion_matrix(test_y, test_pred)

"""**ROC Curve**"""

# ROC Curve
plot_roc_curve(catboost_final, train_X, train_y)
plt.title('Train Veri Seti ROC Curve')
plt.plot([0, 1], [0, 1], 'r--')
plt.show()

plot_roc_curve(catboost_final, test_X, test_y)
plt.title('Train Veri Seti ROC Curve')
plt.plot([0, 1], [0, 1], 'r--')
plt.show()

"""**# Feature Importance**\
Hedef değişkene en çok etki eden değişkenlerin sivil eşe sahip olup olmama, yaş, eğitim süresi ve haftalık çalışma süresi olduğu görülmüştür.
"""

# Feature Importance


def plot_importance(model, features, num=len(test_X), save=False):
    feature_imp = pd.DataFrame({'Value': model.feature_importances_, 'Feature': features.columns})
    plt.figure(figsize=(10, 10))
    sns.set(font_scale=1)
    sns.barplot(x="Value", y="Feature", data=feature_imp.sort_values(by="Value",
                                                                     ascending=False)[0:num])
    plt.title('Features')
    plt.tight_layout()
    plt.show()
    if save:
        plt.savefig('importances.png')


plot_importance(catboost_final, test_X)

"""**Öğrenme Eğrileriyle Model Karmaşıklığının İncelenmesi**"""

# Öğrenme Eğrileriyle Model Karmaşıklığının İncelenmesi


def val_curve_params(model, X, y, param_name, param_range, scoring="roc_auc", cv=10):
    train_score, test_score = validation_curve(
        model, X=X, y=y, param_name=param_name, param_range=param_range, scoring=scoring, cv=cv)

    mean_train_score = np.mean(train_score, axis=1)
    mean_test_score = np.mean(test_score, axis=1)

    plt.plot(param_range, mean_train_score,
             label="Training Score", color='b')

    plt.plot(param_range, mean_test_score,
             label="Validation Score", color='g')

    plt.title(f"Validation Curve for {type(model).__name__}")
    plt.xlabel(f"Number of {param_name}")
    plt.ylabel(f"{scoring}")
    plt.tight_layout()
    plt.legend(loc='best')
    plt.show(block=True)


cat_boost_params = [["iterations", [200, 500]],
                   ["learning_rate", [0.01, 0.1]],
                   ["depth", [3, 6]]]

for i in range(len(cat_boost_params)):
    val_curve_params(catboost_final, train_X, train_y, cat_boost_params[i][0], cat_boost_params[i][1])

for i in range(len(cat_boost_params)):
    val_curve_params(catboost_final, test_X, test_y, cat_boost_params[i][0], cat_boost_params[i][1])

"""**Sonuç ve Değerlendirme**\
Amerika Birleşik Devletleri' nin 1994 Nüfus Sayım Sonuçları' na ait veri seti üzerinden gerçekleştirilen gelir tahmini çalışmasında % 92' lik başarıyla demografik bilgileri verilen bir personanın gelir düzeyinin 50K' dan büyük olup olmadığı tahmin edilmiştir. 

Model çalışmasında türetilen özelliklerinin modele etkisinin kayda değer olmadığı görülmüş olup gelir düzeyinin 50K' dan büyük olmasına etki eden en önemli değişkenlerin sivil bir eşle evli olma, yaş, eğitim durumu, haftalık çalışma süresi ve erkek olma olduğu görülmüştür.
"""